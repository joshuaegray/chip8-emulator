#include <SDL2/SDL.h>
#include "platform.hpp"
#include "../chip8/display.hpp"
#include <iostream>
#include <cmath>


//audio sine function generated by Gemini
void AudioCallback(void* userdata, Uint8* stream, int len) {
    // We use a static variable to keep track of the phase 
    // so the wave is continuous across multiple callback calls.
    static int runningSampleIndex = 0;
    const int sampleRate = 44100;
    const int frequency = 440; // 440Hz (A4) - standard beep pitch
    const int volume = 3000;   // Amplitude (max ~32000 for S16 format)

    Sint16* buffer = (Sint16*)stream; // Treat the stream as 16-bit integers
    int length = len / 2; // We are writing 2 bytes (16 bits) per sample

    for (int i = 0; i < length; i++) {
        // GENERATE SQUARE WAVE
        // If we are in the first half of the cycle, go High. Else, go Low.
        // Math: (Index % (Rate/Freq)) < (Rate/Freq)/2
        int squareWavePeriod = sampleRate / frequency;
        int halfPeriod = squareWavePeriod / 2;
        
        if ((runningSampleIndex % squareWavePeriod) < halfPeriod) {
            buffer[i] = volume;
        } else {
            buffer[i] = -volume;
        }
        
        runningSampleIndex++;
    }

}




SdlPlatform::SdlPlatform(int windowWidth, int windowHeight){
    SDL_Init(SDL_INIT_VIDEO);
    SDL_Init(SDL_INIT_AUDIO);
    SDL_AudioSpec want, have;
    SDL_zero(want);

    want.freq = 44100;
    want.format = AUDIO_S16SYS;
    want.channels = 1;
    want.samples = 2048;
    want.callback = AudioCallback;

    audioDevice = SDL_OpenAudioDevice(NULL, 0, &want, &have, 0);

    if (audioDevice == 0){
        std::cerr << "Error initializing audio" << std::endl;
        exit(1);
    }

    window = SDL_CreateWindow(
        "CHIP-8 Emulator",
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        windowWidth, //width
        windowHeight, //height 
        SDL_WINDOW_SHOWN //Flags
    );

    if (window == NULL){
        std::cerr << "Error creating window" << std::endl;
    }

    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

    SDL_RenderSetLogicalSize(renderer, chip8::SCREEN_WIDTH, chip8::SCREEN_HEIGHT);

    texture = SDL_CreateTexture(renderer, 
        SDL_PIXELFORMAT_ARGB8888,
        SDL_TEXTUREACCESS_STREAMING,
        chip8::SCREEN_WIDTH,
        chip8::SCREEN_HEIGHT
    );


}


SdlPlatform::~SdlPlatform(){

    SDL_DestroyTexture(texture);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_CloseAudioDevice(audioDevice);
    SDL_Quit();
}

void SdlPlatform::render(const Display& display){

    

    //translate 2d display array into flat color buffer
    uint32_t colorBuffer[chip8::SCREEN_HEIGHT * chip8::SCREEN_WIDTH];
    for (uint8_t i = 0; i < chip8::SCREEN_HEIGHT; i ++){
        for (uint8_t j = 0; j < chip8::SCREEN_WIDTH; j++){
            if (display.getPixel(i,j) == 1){
                colorBuffer[i * chip8::SCREEN_WIDTH + j] = 0xFFFFFFFF; //white
            }

            else{
                colorBuffer[i * chip8::SCREEN_WIDTH + j] = 0x00000000; //black
            }
        }
    }


    void* texturePixels;
    int pitch;
    SDL_LockTexture(texture, NULL, &texturePixels, &pitch);
    memcpy(texturePixels, colorBuffer, chip8::SCREEN_HEIGHT * chip8::SCREEN_WIDTH * sizeof(uint32_t));
    SDL_UnlockTexture(texture);
    

    //clear screen
    SDL_RenderClear(renderer);

    //render
    SDL_RenderCopy(renderer, texture, NULL, NULL);
    SDL_RenderPresent(renderer);

}


void SdlPlatform::run(Chip8& emulator){
    uint32_t frameStart;
    int frameTime;
    bool makeSound;
    while (!quit){
        frameStart = SDL_GetTicks();

        processInput(emulator.getKeypad());

        for (int i = 0; i < chip8::CYCLES_PER_FRAME; i ++){
            emulator.cycle();
        }

        //FPS = Timer HZ = 60hz
        makeSound = emulator.updateTimers();
        updateSound(makeSound);    

        render(emulator.getDisplay());

        frameTime = SDL_GetTicks() - frameStart;
        if (chip8::FRAME_DELAY > frameTime){
            SDL_Delay(chip8::FRAME_DELAY - frameTime);
        }
    }
}


void SdlPlatform::processInput(Keypad& keypad) {
    SDL_Event event;

    while (SDL_PollEvent(&event)) {
        switch (event.type) {
            case SDL_QUIT:
                quit = true;
                break;

            case SDL_KEYDOWN:
            case SDL_KEYUP: {
                // Determine if this is a Press (true) or Release (false)
                bool isPressed = (event.type == SDL_KEYDOWN);
                
                // Close on Escape key
                if (event.key.keysym.sym == SDLK_ESCAPE) {
                    quit = true;
                    break;
                }

                // Map SDL Key -> CHIP-8 Key Index
                // If the key isn't in this list, we ignore it.
                switch (event.key.keysym.sym) {
                    case SDLK_x: keypad.setKey(0x0, isPressed); break;
                    case SDLK_1: keypad.setKey(0x1, isPressed); break;
                    case SDLK_2: keypad.setKey(0x2, isPressed); break;
                    case SDLK_3: keypad.setKey(0x3, isPressed); break;
                    case SDLK_q: keypad.setKey(0x4, isPressed); break;
                    case SDLK_w: keypad.setKey(0x5, isPressed); break;
                    case SDLK_e: keypad.setKey(0x6, isPressed); break;
                    case SDLK_a: keypad.setKey(0x7, isPressed); break;
                    case SDLK_s: keypad.setKey(0x8, isPressed); break;
                    case SDLK_d: keypad.setKey(0x9, isPressed); break;
                    case SDLK_z: keypad.setKey(0xA, isPressed); break; // A
                    case SDLK_c: keypad.setKey(0xB, isPressed); break; // B
                    case SDLK_4: keypad.setKey(0xC, isPressed); break; // C
                    case SDLK_r: keypad.setKey(0xD, isPressed); break; // D
                    case SDLK_f: keypad.setKey(0xE, isPressed); break; // E
                    case SDLK_v: keypad.setKey(0xF, isPressed); break; // F
                }
                break;
            }
        }
    }
}


void SdlPlatform::updateSound(bool shouldPlay){
    if (shouldPlay){
        SDL_PauseAudioDevice(audioDevice, 0);
    }

    else{
        SDL_PauseAudioDevice(audioDevice, 1);
    }
}